diff --git a/lib/retry.ex b/lib/retry.ex
index 6b6aa9d..ab282c8 100644
--- a/lib/retry.ex
+++ b/lib/retry.ex
@@ -27,11 +27,10 @@ defmodule Retry do
   The second retry will linearly increase the retry from 10ms following a
   Fibonacci pattern giving up after 10 attempts.
 
-  The third example show how we can product a delay stream using standard
+  The third example shows how we can produce a delay stream using standard
   `Stream` functionality. Any stream of integers may be used as the value of
   `with:`.
 
-
   """
 
   @doc false
@@ -69,21 +68,20 @@ defmodule Retry do
     quote do
       fun = unquote(block_runner(block))
       retry_delays = unquote(stream_builder)
-      delays = Stream.concat([0], retry_delays)
+      delays = [0] |> Stream.concat(retry_delays)
 
-      final_result = Enum.reduce_while(delays, nil, fn(delay, _last_result) ->
+      delays
+      |> Enum.reduce_while(nil, fn(delay, _last_result) ->
         :timer.sleep(delay)
         fun.()
       end)
-
-      case final_result do
+      |> case do
         {:exception, e} -> raise e
         result          -> result
       end
     end
   end
 
-
   @doc """
 
   Retry block of code a maximum number of times with a fixed delay between
@@ -103,7 +101,10 @@ defmodule Retry do
   defmacro retry({:in, _, [retries, sleep]}, do: block) do
     quote do
       import Stream
-  retry([with: [unquote(sleep)] |> cycle |> take(unquote(retries))], do: unquote(block))
+
+      retry([with: [unquote(sleep)]
+      |> cycle
+      |> take(unquote(retries))], do: unquote(block))
     end
   end
 
@@ -152,7 +153,6 @@ defmodule Retry do
     end
   end
 
-
   defp block_runner(block) do
     quote do
       fn ->
diff --git a/lib/retry/delay_streams.ex b/lib/retry/delay_streams.ex
index fdc1733..3eec894 100644
--- a/lib/retry/delay_streams.ex
+++ b/lib/retry/delay_streams.ex
@@ -6,7 +6,6 @@ defmodule Retry.DelayStreams do
 
   """
 
-
   @doc """
 
   Returns a stream of delays that increase exponentially.
@@ -38,7 +37,6 @@ defmodule Retry.DelayStreams do
   def lin_backoff(initial_delay, factor) do
     Stream.unfold(initial_delay, fn last_delay ->
       next_d = last_delay * factor
-
       {next_d, next_d}
     end)
   end
@@ -54,17 +52,14 @@ defmodule Retry.DelayStreams do
         # ...
       end
 
-
   Produces an exponentially increasing delay stream where each delay is randomly
   adjusted to be within 10 percent of the original value
 
-
   """
   def randomize(delays, proportion \\ 0.1) do
     Stream.map(delays, fn d ->
       max_delta = round(d * proportion)
       shift = :rand.uniform(2 * max_delta) - max_delta
-
       d + shift
     end)
   end
@@ -116,14 +111,13 @@ defmodule Retry.DelayStreams do
       remaining_t = Enum.max([end_t - now_t, 0])
 
       cond do
-        :at_end == status             # time expired!
+        :at_end == status              # time expired!
           -> {:halt, status}
         preferred_delay > remaining_t  # one last try
-          ->  {[remaining_t], :at_end}
-       true
+          -> {[remaining_t], :at_end}
+        true
           -> {[preferred_delay], status}
       end
-
     end)
   end
 end
diff --git a/test/retry/delay_streams_test.exs b/test/retry/delay_streams_test.exs
index 1b67b80..79bf891 100644
--- a/test/retry/delay_streams_test.exs
+++ b/test/retry/delay_streams_test.exs
@@ -8,7 +8,7 @@ defmodule Retry.DelayStreamsTest do
     |> Enum.scan(fn (delay, last_delay) ->
       assert delay > last_delay
       delay
-    end )
+    end)
   end
 
   test "lin_backoff/2" do
@@ -17,7 +17,7 @@ defmodule Retry.DelayStreamsTest do
     |> Enum.scan(fn (delay, last_delay) ->
       assert (last_delay * 1.5) == delay
       delay
-    end )
+    end)
   end
 
   test "delay streams can be capped" do
@@ -50,7 +50,7 @@ defmodule Retry.DelayStreamsTest do
     Enum.each(delays, fn (delay) ->
       assert_in_delta delay, 500, 500 * 0.1 + 1
       delay
-    end )
+    end)
 
     assert Enum.any?(delays, &(&1 != 500))
   end
@@ -63,7 +63,7 @@ defmodule Retry.DelayStreamsTest do
     Enum.each(delays, fn (delay) ->
       assert_in_delta delay, 500, 500 * 0.2 + 1
       delay
-    end )
+    end)
 
     assert Enum.any?(delays, &(abs(&1 - 500) > (500 * 0.1)))
   end
diff --git a/test/retry_test.exs b/test/retry_test.exs
index 99c923a..bccea0a 100644
--- a/test/retry_test.exs
+++ b/test/retry_test.exs
@@ -6,11 +6,8 @@ defmodule RetryTest do
   doctest Retry
 
   test "retry(with: _, do: _) retries execution for specified attempts when result is error tuple" do
-
     {elapsed, _} = :timer.tc fn ->
-      import Stream
-
-      result = retry with: lin_backoff(500, 1) |> take(5) do
+      result = retry with: lin_backoff(500, 1) |> Stream.take(5) do
         {:error, "Error"}
       end
 
@@ -41,10 +38,7 @@ defmodule RetryTest do
   end
 
   test "retry(with: _, do: _) works with any Enum" do
-
     {elapsed, _} = :timer.tc fn ->
-      import Stream
-
       result = retry with: [100, 75, 250] do
         {:error, "Error"}
       end
